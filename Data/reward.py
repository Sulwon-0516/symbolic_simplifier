from typing import List
from Data.data_utils import *


def scores(valid_out: List[str], valid_in: List[str], vocab, bin_score=True, LUT=None):
    """
    :param valid_out: tokens generated by decoder and truncated
    :param valid_in: tokens fed into encoder and truncated
    :param vocab: Vocab object
    :param bin_score: equivalence score is binary
    :return: size score, validation score, testing score
    """
    # size score
    size_score = len(valid_in) - len(valid_out)

    # validation score
    input_tree = _validate(valid_in, vocab)
    rewrite_tree = _validate(valid_out, vocab)
    if input_tree is None:
        raise AttributeError("Input Sequence is Illegal:", valid_in)
    valid_score = 0 if rewrite_tree is None else 1

    # test score
    test_score = 0
    if valid_score:
        test_score = _tester(input_tree, rewrite_tree, vocab, bin_score, trials=1000, LUT=LUT)
    return size_score, valid_score, test_score


def _validate(tokens, vocab):
    try:
        tree = parse_expression(tokens, vocab)
        s = int(validate_tree(tree, vocab))
    except ValueError as e:
        s = 0
        # print("invalid expression: ", tokens, "\n", e)
    if s == 0:
        return None
    return tree


def _tester(input_tree, rewrite_tree, vocab, binary, trials=1000, LUT=None):
    # whatever can be reduced to const, do not duplicate test
    score = 0
    vars1 = input_tree.get_const_var_set()
    vars2 = rewrite_tree.get_const_var_set()
    v_list = vars1.union(vars2)
    feed_dict = dict()
    variables = list()
    constants = list()
    for k in v_list:
        const = vocab.to_const(k)
        if LUT is not None and k in LUT:
            constants.append(LUT[k])
            feed_dict[k] = LUT[k]
        elif const is None:
            variables.append(k)
        else:
            constants.append(const)
            feed_dict[k] = const
    # print(feed_dict, variables)
    if len(variables) == 0:
        try:
            return __compare_res(input_tree, rewrite_tree, vocab, feed_dict)
        except ValueError:
            return 0
    # test assigning same constant value to
    discount = 0
    division_errors = 0
    for c in constants:
        feed_dict.update({k: c for k in variables})
        try:
            score += __compare_res(input_tree, rewrite_tree, vocab, feed_dict)
        except ValueError:
            if binary:
                return 0
            score += 1
            division_errors += 1
        discount += 1
        if binary and score != discount:
            # print(feed_dict)
            return 0
    for k in variables:
        feed_dict.update({v: 1 for v in variables})
        feed_dict[k] = 0
        try:
            score += __compare_res(input_tree, rewrite_tree, vocab, feed_dict)
        except ValueError:
            score += 1
            division_errors += 1
        discount += 1
        if binary and score != discount:
            # print(feed_dict)
            return 0

    group = 6
    step = discount
    while step < trials:
        trail_group = step % group
        if trail_group == 0:
            # bool testing
            values = np.random.choice([True, False], len(variables)).tolist()
        elif trail_group == 1:
            # int testing
            values = np.random.normal(loc=0, scale=1024, size=len(variables)).astype(int).tolist()
        elif trail_group == 2:
            # float testing
            values = np.random.normal(loc=0, scale=1024, size=len(variables)).tolist()
        elif trail_group >= 3:
            # mixed type
            values = list()
            types = np.random.choice([0, 1, 2], len(variables))
            for t in types:
                if t == 0:
                    values.extend(np.random.choice([True, False], 1).tolist())
                elif t == 1:
                    values.extend(np.random.normal(0, 1024, 1).astype(int).tolist())
                else:
                    values.extend(np.random.normal(0, 1024, 1).tolist())
        feed_dict.update({k: v for k, v in zip(variables, values)})
        try:
            score += __compare_res(input_tree, rewrite_tree, vocab, feed_dict)
        except ValueError:
            score += 1
            division_errors += 1
        # print(score)
        step += 1
        # print(discount, step, score, "< ? ", step)
        if binary and score < step:
            # print(feed_dict)
            return 0
    if binary:
        if division_errors > trials / 2:
            return 0
        return 1
    return (score - division_errors)/ trials


def __compare_res(tree1, tree2, vocab, feed_dict):
    try:
        res_in = tree1.execute(vocab, feed_dict)
    except ZeroDivisionError:
        res_in = None
    try:
        res_out = tree2.execute(vocab, feed_dict)
    except ZeroDivisionError:
        res_out = None
    if res_out is None and res_in is None:
        return 1
    if res_in is None or res_out is None:
        raise ValueError("ZeroDivision Not consistant")
    if type(res_in) == bool:
        if type(res_out) == bool:
            return int(res_in == res_out)
        else:
            return int(type(res_in)(res_out) == res_in)
    elif type(res_in) == int:
        if type(res_out) == bool:
            return res_in == int(res_out)
        if type(res_out) == int:
            return int(res_in == res_out)
        else:
            return 0
    else:
        if abs(res_in - res_out) < 1e-7:
            return True
        return int(abs(res_in - res_out) / max(abs(res_out), abs(res_in)) < 1e-7)


if __name__ == "__main__":
    from Data.halide_utils import HalideVocab

    vocab = HalideVocab()
    vocab.add_word("w")
    vocab.add_word("y")
    vocab.add_word("z")
    print(scores(
        ['min', '(', 'min', '(', 'y', ',', 'w', ')', ',', 'z', ')'],
        ['min', '(', 'y', ',', 'w', ')'], vocab))

    print(scores(
        ['min', '(', 'min', '(', 'y', ',', 'w', ')', ',', 'z', ')'],
        ['min', '(', 'min', '(', 'z', ',', 'w', ')', ',', 'y', ')'], vocab))

    print(scores(['y'],
        ['w', '*', '(', 'y', '/', 'w', ')'], vocab))

    print(scores(['y'],
        ['z', '*', '(', 'y', '/', 'z', ')'], vocab, LUT={'z': 8}))

